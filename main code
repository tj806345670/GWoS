############ multiple imputation 
rm(list = ls())
library(mice)
library(tidyr)
library(openxlsx)
set.seed(22112)
envcogdata<-read.xlsx('/envcogdata.xlsx')
test<-list()
ignore <- caret::createFolds(y=1:dim(envcogdata)[1],k=10)### 分成10份
allind<-as.numeric(unlist(ignore))
for (i in 1:10) {
  imp <- mice(envcogdata[,-1],maxit = 20, m = 10, ignore = as.numeric(rownames(envcogdata)) %in% ignore[[i]], print = F, seed = 22112)
  test[[paste0('Fold',i)]] <- filter(imp, as.numeric(rownames(envcogdata)) %in% ignore[[i]])
}
# get 10 complete datasets
impdata<-list()
for (im in 1:10) {
  tmpc<-mice::complete(test[["Fold1"]], im)
  for (f in 2:10) {
    tmp<-mice::complete(test[[paste0('Fold',f)]], im)
    tmpc<- rbind(tmpc,tmp)
  }
  tmpc<-data.frame(subid= envcogdata[allind,'subid'], tmpc [,])
  tmpc<-tmpc[order(tmpc$subid),]
  impdata[[im]]<-tmpc
}
# check
sum(impdata[[1]][["sex"]]- envcogdata$sex)
########### mean imputed dataset 
meanimp<-impdata[[1]]
for ( i in 2:length(impdata)) {
  meanimp<-meanimp+impdata[[i]]
}
save.image("/impdataR2.RData")

############ PSM to 1:1 create OC and non-OC pairs
load("/impdataR2.RData")
library(MatchIt)
library(tidyr)
library(openxlsx)
set.seed(123)
model <-matchit(OC ~  PC1+PC2+PC3+PC4+PC5+PC6+PC7+PC8+PC9+PC10+sex+age_covs+agesex+edu_covs+BMI+TIV+mean_FD,data = meanimp,method ="nearest" ,caliper =0.2, distance ="bart")
summary(model)
matched_samples <- match.data(model)
rownames(matched_samples)<-NULL
matched2 <- reshape(matched_samples, direction = "wide", idvar = "subclass", timevar = "OC")

############function for paired-sample t-test
pairedTtest<-function (phenoname,widedata,datatype) {
  result<-data.frame()
  c<-0
  for (i in phenoname) {
    c<-c+1
    tmp<-widedata[,c(paste0(i,'.1'),paste0(i,'.0'))]
    names(tmp)[1]<-'pheno1'
    names(tmp)[2]<-'pheno2'
    fit<-t.test(Pair(pheno1, pheno2) ~ 1, data = tmp)
    result[c,datatype]<-i
    result[c,'t']<- fit[["statistic"]][["t"]]
    result[c,'p']<- fit[["p.value"]]
    result[c,'NOC']<-dim(tmp)[1]
    result[c,'NnonOC']<-dim(tmp)[1]
    result[c,'meanOC']<-mean(tmp[,1])
    result[c,'stdOC']<-sd(tmp[,1])
    result[c,'meannonOC']<-mean(tmp[,2])
    result[c,'stdnonOC']<-sd(tmp[,2])
    result[c,'md']<-fit[["estimate"]][["mean of the differences"]]
    result[c,'se2']<- (fit[["stderr"]])^2
    result[c,'df']<-fit[["parameter"]][["df"]]
    result[c,'Cohend']<-lsr::cohensD(tmp$pheno1,tmp$pheno2,method ='paired')
    TLCI<-fit[["conf.int"]][1]/fit[["stderr"]]
    TUCI<-fit[["conf.int"]][2]/fit[["stderr"]]
    result[c,'Cohend_LCI']<-TLCI/sqrt(result[c,'NOC'])
    result[c,'Cohend_UCI']<-TUCI/sqrt(result[c,'NOC'])    
  }
  return(result)
}
resultcog<-pairedTtest(cognames,mergedata,'Behavior')
resultenv<-pairedTtest(envnames,mergedata,'PEE')
resulttract<-pairedTtest(tractnames,mergedata,'Tracts')

########### pool the results according to Rubin's Rules
nim<-10 # number of imputation
md <- do.call(cbind, lapply(result10, function(df) df[['md']]))
mdpool<-rowMeans(md) 
SE2<-do.call(cbind, lapply(result10, function(df) df[['se2']]))
Vw<- rowMeans(SE2)
Vb<- rowSums((md-mdpool)^2)/(nim-1)
Vtotal<- Vw+Vb+(Vb/nim)
SEpool<-sqrt(Vtotal)
Waldpool<-mdpool/SEpool
lambda<- (Vb+(Vb/nim))/Vtotal
dfold<- (nim-1)/(lambda^2)
n=resultcog10[[im]][1,'NOC'] 
k=1 #k the number of parameters to fit 1 for paired T-test
dfobs<- ( (n-k+1)/(n-k+3) )*(n-k)*(1-lambda)
dfadj<- (dfold*dfobs)/(dfold+dfobs)# adjusted df
pvalue<- 2*pt(abs(Waldpool),dfadj,lower.tail = F)

result$pooledP<-pvalue
result$FMI=FMI
result$mdpool<-mdpool
t_critical <- qt(1 - 0.05/2, df = dfadj) 
CI<-data.frame(CI1=mdpool-(t_critical*SEpool),CI2=mdpool+(t_critical*SEpool))
TLCI<-apply(CI,1,min)/SEpool
TUCI<-apply(CI,1,max)/SEpool
result$Tpool<-Waldpool
result$Cohendpool<-result$Tpool/sqrt(result$NOC)
result$dfadj<- dfadj
result$Cohendpool_LCI<- TLCI/sqrt(result$NOC)
result$Cohendpool_UCI<- TUCI/sqrt(result$NOC)
  



